#Binary Search Tree

En el peor caso es un O(n)

#add

O (log n) por la forma en que tiene que ser ordenado, un nodo puede tener dos hijos

#inorder

O (log n) por que tiene que recorrer dos posibles ordenes por nodo

#preorder

O (log n) por que tiene que recorrer dos posibles ordenes por nodo

#postorder

O (log n) por que tiene que recorrer dos posibles ordenes por nodo

#levelorder

O (log n) por que tiene que recorrer dos posibles ordenes por nodo

#height

O(n) dependiendo solo del nodo mas lejano a la raiz

#ancestors 

O(n) hace un retroceso apartir de un hijo recorriendo a los nodos superiores

#whatlevelamI

O(n) depende de cantidad de ramas que se encuentran 
